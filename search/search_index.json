{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home / Introduction","text":"<p>\ud83c\udfe0 Home | \ud83c\udfa8 Design | \ud83e\udde0 Algorithm | \ud83d\udc1e Debugging | \ud83e\udde0 Reflection</p>"},{"location":"#digital-rain-in-modern-c","title":"\ud83c\udf27\ufe0f Digital Rain in Modern C++","text":"<p>Welcome to my blog on creating a Digital Rain effect using Modern C++! This project was inspired by the iconic Matrix-style digital rain, and explores graphics, algorithm design, and performance.</p> <p>\ud83d\udc49 Jump to the Design | See the Code | Debugging | Reflection</p>"},{"location":"#project-overview","title":"\ud83c\udfaf Project Overview","text":"<ul> <li>\u2705 Random falling characters</li> <li>\u2705 Character fading/lifespan</li> <li>\u2705 Real-time Windows console rendering</li> <li>\u2705 Modular object-oriented design</li> </ul>"},{"location":"algorithm/","title":"Algorithm Details","text":"<p>\ud83c\udfe0 Home | \ud83c\udfa8 Design | \ud83e\udde0 Algorithm | \ud83d\udc1e Debugging | \ud83e\udde0 Reflection</p>"},{"location":"algorithm/#random-drop-creation","title":"\ud83c\udfb2 Random Drop Creation","text":"<p>Each column has a 10% chance to create a new drop per frame if it\u2019s empty.</p> <pre><code>if (rand() % 100 &lt; 10 &amp;&amp; columns[x].empty()) {\n    createNewDrop(x);\n}\n</code></pre> <ul> <li> <p>A 10% chance is used to control spawn frequency.</p> </li> <li> <p>Prevents drops from stacking unnaturally.</p> </li> <li> <p>Drop lifespan, position, and color are randomized</p> </li> </ul>"},{"location":"algorithm/#fading-and-deletion","title":"\ud83d\udca1 Fading and Deletion","text":"<p>Characters fade as their <code>life</code> reduces. Below <code>life &lt; 5</code>, intensity is dimmed.</p> <pre><code>if (dc.life &lt; 5) {\n    color = dc.color &amp; ~FOREGROUND_INTENSITY;\n}\n</code></pre> <p>The animation is driven by a real-time loop in <code>DigitalRain::run()</code>:</p> <pre><code>while (!_kbhit()) {\n    update();\n    render();\n    Sleep(50); // Delay between frames\n}\n</code></pre> <p>This loop: - Continuously updates the state of all falling characters. - Redraws only the necessary parts of the screen. - Exits gracefully when a key is pressed using _kbhit().</p>"},{"location":"design/","title":"\ud83c\udfa8 Design &amp; Test","text":"<p>\ud83c\udfe0 Home | \ud83c\udfa8 Design | \ud83e\udde0 Algorithm | \ud83d\udc1e Debugging | \ud83e\udde0 Reflection</p>"},{"location":"design/#architecture-overview","title":"\ud83e\uddf1 Architecture Overview","text":"<p>The project is built using modern C++ and is structured around three main components:</p> <ul> <li><code>DigitalRain</code>: Controls the main animation loop, frame updates, console state, and rendering.</li> <li><code>DropChar</code>: A struct that holds information for a single falling character (position, life, value, color).</li> <li><code>CharacterStream</code>: A helper class that provides randomized alphanumeric characters for display.</li> </ul>"},{"location":"design/#dropchar-structure","title":"<code>DropChar</code> Structure","text":"<pre><code>struct DropChar {\n    int position;   // Vertical Y position\n    int life;       // Remaining lifespan\n    char value;     // Character to render\n    WORD color;     // Console text color\n};\n</code></pre>"},{"location":"design/#object-relationships","title":"\ud83d\udce6 Object Relationships","text":"<p>The main simulation is built around a vertical column structure:</p> <ul> <li><code>std::vector&lt;std::list&lt;DropChar&gt;&gt; columns</code>: each vector index corresponds to a column on screen.</li> <li>Each <code>DropChar</code> in the list is a character that is falling in that column.</li> <li>Characters are created, updated, and erased in real-time.</li> </ul> <pre><code>std::vector&lt;std::list&lt;DropChar&gt;&gt; columns;\n</code></pre> <p>Characters are spawned via:</p> <pre><code>createNewDrop(x);\n</code></pre> <p>Where <code>x</code> is the column index and the new drop is added at the top.</p>"},{"location":"design/#testing-strategy","title":"\u2705 Testing Strategy","text":"<p>Testing was done through both code-driven validation and visual inspection.</p>"},{"location":"design/#manual-console-resizing","title":"\ud83d\udda5\ufe0f Manual Console Resizing","text":"<ul> <li>Console width and height are detected using:</li> </ul> <pre><code>GetConsoleScreenBufferInfo(hConsole, &amp;csbi);\n</code></pre> <ul> <li>If dimensions change, the column layout is reinitialized:</li> </ul> <pre><code>if (newWidth != consoleWidth || newHeight != consoleHeight) {\n    consoleWidth = newWidth;\n    consoleHeight = newHeight;\n    columns = std::vector&lt;std::list&lt;DropChar&gt;&gt;(consoleWidth);\n}\n</code></pre>"},{"location":"design/#keyboard-exit","title":"\ud83e\uddea Keyboard Exit","text":"<ul> <li>Used <code>_kbhit()</code> to detect key presses for clean exit during runtime.</li> </ul> <pre><code>while (!_kbhit()) {\n    update();\n    render();\n    Sleep(50);\n}\n</code></pre>"},{"location":"design/#visual-inspection","title":"\ud83d\udc41\ufe0f Visual Inspection","text":"<ul> <li>Ensured proper behavior:</li> <li>Characters move smoothly</li> <li>Drops fade and disappear over time</li> <li>No overlapping glitches</li> <li>Fading check using bitwise logic:</li> </ul> <pre><code>if (dc.life &lt; 5) {\n    color = dc.color &amp; ~FOREGROUND_INTENSITY;\n}\n</code></pre>"},{"location":"design/#key-design-choices","title":"\ud83e\udde0 Key Design Choices","text":""},{"location":"design/#efficient-console-rendering","title":"\ud83d\udfe2 Efficient Console Rendering","text":"<ul> <li>\u274c Avoided <code>system(\"cls\")</code> because it causes flicker and screen tear.</li> <li>\u2705 Used <code>SetConsoleCursorPosition()</code> for precise, fast updates:</li> </ul> <pre><code>SetConsoleCursorPosition(hConsole, { (SHORT)x, (SHORT)dc.position });\nstd::cout &lt;&lt; dc.value;\n</code></pre>"},{"location":"design/#fade-effect-using-bitmask","title":"\ud83d\udfe2 Fade Effect Using Bitmask","text":"<ul> <li>Bitwise logic was used to dim colors when drops are nearly expired:</li> </ul> <pre><code>color = dc.color &amp; ~FOREGROUND_INTENSITY;\n</code></pre>"},{"location":"design/#smart-data-structures","title":"\ud83d\udfe2 Smart Data Structures","text":"<ul> <li><code>std::list</code> allows for safe in-loop erasure of expired characters:</li> </ul> <pre><code>if (it-&gt;life &lt;= 0 || it-&gt;position &gt;= consoleHeight) {\n    it = columns[x].erase(it);\n}\n</code></pre> <ul> <li><code>std::vector</code> gives O(1) access per column and is resized dynamically.</li> </ul>"},{"location":"design/#modular-reusable","title":"\ud83d\udfe2 Modular &amp; Reusable","text":"<ul> <li>All logic is encapsulated in methods (<code>initialize</code>, <code>update</code>, <code>render</code>, <code>cleanup</code>).</li> <li>Clean separation of logic (animation vs. rendering vs. data).</li> </ul>"},{"location":"design/#summary","title":"\ud83d\udccc Summary","text":"<p>This project uses modern C++ to create a visually engaging animation inside the Windows console. Using the Windows API directly (rather than libraries or screen clearing) results in a smoother, more responsive simulation. The architecture is modular, efficient, and well-suited for further expansion such as colored trails, sound, or input interaction.</p>"},{"location":"problemsolving/","title":"\ud83d\udc1e Problem Solving","text":"<p>\ud83c\udfe0 Home | \ud83c\udfa8 Design | \ud83e\udde0 Algorithm | \ud83d\udc1e Debugging | \ud83e\udde0 Reflection</p>"},{"location":"problemsolving/#character-glitches","title":"\u274c Character Glitches","text":""},{"location":"problemsolving/#problem","title":"\ud83d\udd0d Problem:","text":"<p>At first, some characters were rendering as strange symbols (like <code>?</code>, <code>\ufffd</code>, etc.). This happened because the default <code>rand()</code> could return values that didn\u2019t map to readable or printable ASCII characters.</p>"},{"location":"problemsolving/#solution","title":"\u2705 Solution:","text":"<p>I fixed this by creating a limited, clean character set using only alphanumeric characters. That ensured all generated characters would look visually consistent in the console.</p> <pre><code>const char charset[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nreturn charset[rand() % (sizeof(charset) - 1)];\n</code></pre> <p>This completely removed the weird symbols and made the falling rain look more realistic and readable.</p>"},{"location":"problemsolving/#flicker-fix","title":"\ud83d\udcbb Flicker Fix","text":""},{"location":"problemsolving/#problem_1","title":"\ud83d\udd0d Problem:","text":"<p>Originally, I used <code>system(\"cls\")</code> to clear the screen each frame, but this caused constant flickering and performance issues.</p>"},{"location":"problemsolving/#solution_1","title":"\u2705 Solution:","text":"<p>I replaced it with <code>SetConsoleCursorPosition()</code> from the Windows API. Instead of clearing the entire screen, this simply moves the cursor to the location of each character and overwrites it \u2014 resulting in smooth rendering.</p> <pre><code>SetConsoleCursorPosition(hConsole, { (SHORT)x, (SHORT)it-&gt;position });\nstd::cout &lt;&lt; dc.value;\n</code></pre> <p>This small change made the animation look way more stable and fluid.</p>"},{"location":"problemsolving/#drop-overlap-life-management","title":"\ud83e\uddf1 Drop Overlap &amp; Life Management","text":""},{"location":"problemsolving/#problem_2","title":"\ud83d\udd0d Problem:","text":"<p>Sometimes drops would overlap, or stay on screen forever if not cleared properly.</p>"},{"location":"problemsolving/#solution_2","title":"\u2705 Solution:","text":"<p>To fix that, I added a <code>life</code> property to each <code>DropChar</code>. On every frame, the drop moves down and its life is reduced. When <code>life &lt;= 0</code>, it's removed from the list safely during iteration.</p> <pre><code>if (it-&gt;life &lt;= 0 || it-&gt;position &gt;= consoleHeight) {\n    it = columns[x].erase(it); // Safe in-place erase using list iterator\n} else {\n    ++it;\n}\n</code></pre> <p>This kept the screen clean and let the animation loop without getting cluttered or buggy.</p>"},{"location":"problemsolving/#console-resize-bugs","title":"\ud83d\udcd0 Console Resize Bugs","text":""},{"location":"problemsolving/#problem_3","title":"\ud83d\udd0d Problem:","text":"<p>If the console was resized while running, the layout would break and characters would start overlapping or disappear.</p>"},{"location":"problemsolving/#solution_3","title":"\u2705 Solution:","text":"<p>I detected console width and height dynamically each frame and reallocated the grid if it changed:</p> <pre><code>GetConsoleScreenBufferInfo(hConsole, &amp;csbi);\nint newWidth = csbi.srWindow.Right - csbi.srWindow.Left + 1;\nint newHeight = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;\n\nif (newWidth != consoleWidth || newHeight != consoleHeight) {\n    consoleWidth = newWidth;\n    consoleHeight = newHeight;\n    columns = std::vector&lt;std::list&lt;DropChar&gt;&gt;(consoleWidth); // Reset columns\n}\n</code></pre> <p>This made it much more robust \u2014 the rain now adjusts automatically if I resize the window!</p>"},{"location":"problemsolving/#summary","title":"\ud83d\udca1 Summary","text":"<p>Debugging this project taught me a lot about console behavior, rendering performance, and clean real-time logic. Most bugs were solved by simplifying logic, choosing better data structures (like <code>std::list</code>), or using low-level API features like cursor control instead of hacks like <code>cls</code>.</p> <p>It was honestly fun to fix things because I could instantly see the difference visually in the animation. \ud83d\ude42</p>"},{"location":"reflection/","title":"\ud83e\udde0 Reflection &amp; Modern C++","text":""},{"location":"reflection/#learning-journey","title":"\ud83d\udcda Learning Journey","text":"<p>Working on the Digital Rain project was honestly one of the most fun coding tasks I've done. It really helped me understand how real-time animations work in the console and gave me a better grasp of how to structure a C++ program using modern techniques. Seeing the characters fall and fade in real time felt really satisfying.</p>"},{"location":"reflection/#modern-c-practices-used","title":"\ud83e\uddf0 Modern C++ Practices Used","text":"<ul> <li>Object-Oriented Design: Classes like <code>DigitalRain</code> and <code>CharacterStream</code> encapsulate logic and allow for reuse and modular design.</li> <li>Standard Library Containers: Used <code>std::vector</code> and <code>std::list</code> to manage dynamic character streams and enable efficient insert/delete.</li> <li>Scoped Initialization: Used <code>{}</code> initialization, <code>auto</code>, and RAII principles.</li> <li>Randomization &amp; Seeding: Used <code>srand(static_cast&lt;unsigned int&gt;(time(nullptr)))</code> to ensure randomness across runs.</li> </ul>"},{"location":"reflection/#what-i-learned","title":"\ud83d\udcac What I Learned","text":"<ul> <li>Efficient rendering without flickering requires precise cursor control and selective redrawing.</li> <li>Managing lifecycles of visual elements (drops) introduces game loop logic in a console app.</li> <li>MkDocs is a powerful tool for documenting C++ projects and aligns well with GitHub Pages deployment.</li> </ul>"},{"location":"reflection/#future-iteration","title":"\ud83d\udd2e Future Iteration","text":"<ul> <li>Use <code>std::chrono</code> and C++20 coroutines for smoother frame management.</li> <li>Integrate user interactivity (pause, speed control).</li> <li>Explore Unicode support for more authentic glyphs.</li> </ul> <p>\ud83c\udfe0 Home | \ud83c\udfa8 Design | \ud83e\udde0 Algorithm | \ud83d\udc1e Debugging | \ud83e\udde0 Reflection</p>"}]}